# V1.5 Implementation Plan: Store Selection & Furniture Removal

## Overview
This version adds two major features:
1. **Multi-Store Selection** - Users can choose which stores to shop from
2. **Automatic Furniture Removal** - AI-powered furniture removal from uploaded room images

## Feature 1: Store Selection Page

### User Flow
1. HomePage: Upload image → Trigger furniture removal → Navigate to `/store-select`
2. Store Select: Choose stores (or none = all stores) → Navigate to `/design`
3. Design Page: View recommendations from selected stores → Can edit store selection anytime

### Implementation Details

#### 1. Store Selection Page (`frontend/src/app/store-select/page.tsx`) - NEW
- Fetch available stores from `GET /api/stores`
- Multi-select UI with checkboxes/chips
- "Select All" / "Deselect All" buttons
- No stores pre-selected by default
- Save selection to sessionStorage as `primaryStores`
- If no stores selected → pass empty array (backend treats as "all stores")
- Navigate to `/design`

#### 2. Backend Store List Endpoint (`api/routers/stores.py`) - NEW
```python
@router.get("/stores")
async def get_available_stores(db: AsyncSession = Depends(get_db)):
    """Get list of stores with available products"""
    query = select(Product.source_website).where(
        Product.is_available == True
    ).distinct()
    result = await db.execute(query)
    stores = [row[0] for row in result.fetchall()]
    return {"stores": sorted(stores)}
```

#### 3. Update Routing
- **HomePage** (`frontend/src/app/page.tsx`):
  - Change navigation from `/design` → `/store-select`
  - Both "Continue with image" and "Skip upload" go to `/store-select`

- **Design Page** (`frontend/src/app/design/page.tsx`):
  - Load `primaryStores` from sessionStorage
  - Pass to ChatPanel for backend queries

#### 4. Backend Filtering (`api/services/recommendation_engine.py`)
- Add `selected_stores: Optional[List[str]] = None` to `RecommendationRequest` dataclass
- In `_get_candidate_products()`:
  ```python
  query = select(Product).where(Product.is_available)

  # Store filtering
  if request.selected_stores and len(request.selected_stores) > 0:
      query = query.where(Product.source_website.in_(request.selected_stores))
  # If empty or None, search all stores (no filter)
  ```

#### 5. Chat API Update (`api/routers/chat.py`)
- Add `selected_stores: Optional[List[str]] = None` to `ChatRequest` schema
- Pass to recommendation engine:
  ```python
  recommended_products = await _get_product_recommendations(
      analysis, db,
      user_message=request.message,
      selected_stores=request.selected_stores,
      limit=30
  )
  ```

#### 6. Design Page Store Editor (`frontend/src/app/design/page.tsx`)
- Add "Change Stores" button in header/toolbar
- Open modal with store selection UI (reuse component logic)
- Show currently selected stores (pre-checked)
- On "Apply":
  - Update `primaryStores` in sessionStorage
  - Keep existing chat history
  - Clear current products
  - Re-fetch recommendations with new store filter
- ProductDiscoveryPanel's secondary filter resets

### Two-Level Filtering Architecture

**Primary Store Selection (Backend Query)**
- Selected on store-select page
- Editable from design page via "Change Stores" button
- Filters products at database level
- Sent to backend in recommendation API calls
- Stored in sessionStorage as `primaryStores`

**Secondary Store Filtering (Frontend)**
- Already exists in ProductDiscoveryPanel
- Filters within already-returned products
- Client-side only
- Stored in component state

## Feature 2: Automatic Furniture Removal

### User Flow
1. User uploads image on HomePage
2. Backend starts async furniture removal (3 retries, timeout)
3. User proceeds to store-select (non-blocking)
4. User selects stores and goes to design page
5. Design page shows processing overlay until image ready
6. Once complete, show processed image and enable interactions
7. On failure after 3 retries, fallback to original image

### Processing Requirements
- **Async processing** - Non-blocking, continues in background
- **Retry logic** - 3 attempts with timeout
- **Caching** - Don't reprocess same image
- **Fallback** - Use original image if all retries fail
- **Blocking UI** - Design page blocks interactions until processing complete

### Gemini Prompt for Furniture Removal

```
You are an expert interior design assistant specializing in room preparation.

Your task is to remove ALL furniture and movable decorative items from this room image while preserving everything else EXACTLY as it appears.

REMOVE (if present):
- All furniture items: sofas, chairs, tables, beds, dressers, cabinets, shelves
- Movable decorations: lamps, vases, picture frames, sculptures, rugs, cushions
- Electronics: TVs, computers, speakers placed in the room
- Plants and planters (if movable)
- Any other movable objects or furnishings

PRESERVE EXACTLY AS-IS:
- Room architecture: walls, ceiling, floors
- Built-in features: moldings, wainscoting, baseboards, crown molding
- Windows, doors, and their frames
- Fixed lighting fixtures: ceiling lights, wall sconces, recessed lighting
- Flooring patterns, textures, and materials
- Wall colors, textures, wallpaper, paint
- Natural and artificial lighting (maintain the same lighting conditions)
- Room dimensions and spatial characteristics
- Any architectural details or built-in elements

CRITICAL REQUIREMENTS:
1. Do NOT change wall colors, floor colors, or any surface materials
2. Do NOT alter lighting, shadows, or room ambiance
3. Do NOT add, modify, or enhance any architectural features
4. Do NOT change the perspective, angle, or framing of the image
5. Maintain the exact same image resolution and quality
6. Fill removed furniture areas naturally to match surrounding floor/wall
7. The result should look like an empty, unfurnished version of the same room

The goal is to create a clean, empty room that maintains ALL original architectural and design characteristics, ready for new furniture placement and design visualization.
```

### Implementation Details

#### 1. Job Tracking Service (`api/services/furniture_removal_service.py`) - NEW
```python
from dataclasses import dataclass
from typing import Dict, Optional
import uuid
from datetime import datetime

@dataclass
class FurnitureRemovalJob:
    job_id: str
    status: str  # pending, processing, completed, failed
    original_image: str
    processed_image: Optional[str]
    retries: int
    created_at: datetime
    updated_at: datetime

class FurnitureRemovalService:
    def __init__(self):
        self.jobs: Dict[str, FurnitureRemovalJob] = {}
        self.cache: Dict[str, str] = {}  # image_hash -> processed_image

    def create_job(self, image: str) -> str:
        """Create new job, check cache first"""
        image_hash = hashlib.md5(image.encode()).hexdigest()

        if image_hash in self.cache:
            # Return cached result immediately
            job_id = str(uuid.uuid4())
            self.jobs[job_id] = FurnitureRemovalJob(
                job_id=job_id,
                status="completed",
                original_image=image,
                processed_image=self.cache[image_hash],
                retries=0,
                created_at=datetime.utcnow(),
                updated_at=datetime.utcnow()
            )
            return job_id

        # Create new processing job
        job_id = str(uuid.uuid4())
        self.jobs[job_id] = FurnitureRemovalJob(
            job_id=job_id,
            status="pending",
            original_image=image,
            processed_image=None,
            retries=0,
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow()
        )
        return job_id

    def get_job(self, job_id: str) -> Optional[FurnitureRemovalJob]:
        return self.jobs.get(job_id)

    def update_job(self, job_id: str, status: str, processed_image: Optional[str] = None):
        if job_id in self.jobs:
            self.jobs[job_id].status = status
            if processed_image:
                self.jobs[job_id].processed_image = processed_image
            self.jobs[job_id].updated_at = datetime.utcnow()

    def cache_result(self, image: str, processed_image: str):
        image_hash = hashlib.md5(image.encode()).hexdigest()
        self.cache[image_hash] = processed_image

# Global instance
furniture_removal_service = FurnitureRemovalService()
```

#### 2. Google AI Service Update (`api/services/google_ai_service.py`)
```python
async def remove_furniture(self, image_base64: str, max_retries: int = 3) -> Optional[str]:
    """Remove furniture from room image with retry logic"""

    prompt = """[Full prompt from above]"""

    for attempt in range(max_retries):
        try:
            response = await self.model.generate_content_async([
                prompt,
                {"mime_type": "image/jpeg", "data": image_base64}
            ])

            if response and hasattr(response, 'image'):
                return response.image  # Return processed image base64

        except Exception as e:
            logger.error(f"Furniture removal attempt {attempt + 1} failed: {e}")
            if attempt < max_retries - 1:
                await asyncio.sleep(2 ** attempt)  # Exponential backoff
            continue

    return None  # Failed after all retries
```

#### 3. Furniture Removal API (`api/routers/furniture.py`) - NEW
```python
from fastapi import APIRouter, BackgroundTasks

router = APIRouter(prefix="/api/furniture", tags=["furniture"])

@router.post("/remove")
async def start_furniture_removal(
    request: dict,
    background_tasks: BackgroundTasks,
    google_ai: GoogleAIService = Depends(get_google_ai_service)
):
    """Start async furniture removal job"""
    image = request.get("image")

    # Create job (checks cache)
    job_id = furniture_removal_service.create_job(image)

    job = furniture_removal_service.get_job(job_id)
    if job.status == "completed":
        # Cache hit, return immediately
        return {"job_id": job_id, "status": "completed"}

    # Start background processing
    background_tasks.add_task(process_furniture_removal, job_id, image, google_ai)

    return {"job_id": job_id, "status": "pending"}

async def process_furniture_removal(job_id: str, image: str, google_ai: GoogleAIService):
    """Background task for furniture removal"""
    furniture_removal_service.update_job(job_id, "processing")

    processed_image = await google_ai.remove_furniture(image, max_retries=3)

    if processed_image:
        furniture_removal_service.update_job(job_id, "completed", processed_image)
        furniture_removal_service.cache_result(image, processed_image)
    else:
        furniture_removal_service.update_job(job_id, "failed")

@router.get("/status/{job_id}")
async def get_furniture_removal_status(job_id: str):
    """Check status of furniture removal job"""
    job = furniture_removal_service.get_job(job_id)

    if not job:
        return {"error": "Job not found"}, 404

    response = {
        "status": job.status,
        "job_id": job_id
    }

    if job.status == "completed" and job.processed_image:
        response["image"] = job.processed_image
    elif job.status == "failed":
        response["image"] = job.original_image  # Fallback to original

    return response
```

#### 4. HomePage Integration (`frontend/src/app/page.tsx`)
```typescript
const handleContinueWithImage = async () => {
  if (roomImage) {
    // Start furniture removal
    const response = await startFurnitureRemoval(roomImage);

    // Store job ID and original image
    sessionStorage.setItem('furnitureRemovalJobId', response.job_id);
    sessionStorage.setItem('roomImage', roomImage);

    // Navigate immediately (non-blocking)
    router.push('/store-select');
  }
};
```

#### 5. Design Page Processing UI (`frontend/src/app/design/page.tsx`)
```typescript
const [isProcessing, setIsProcessing] = useState(false);
const [processedImage, setProcessedImage] = useState<string | null>(null);

useEffect(() => {
  const jobId = sessionStorage.getItem('furnitureRemovalJobId');
  const originalImage = sessionStorage.getItem('roomImage');

  if (jobId) {
    setIsProcessing(true);
    pollFurnitureRemovalStatus(jobId);
  } else if (originalImage) {
    setProcessedImage(originalImage);
  }
}, []);

const pollFurnitureRemovalStatus = async (jobId: string) => {
  const interval = setInterval(async () => {
    const response = await checkFurnitureStatus(jobId);

    if (response.status === 'completed' || response.status === 'failed') {
      setProcessedImage(response.image);
      setIsProcessing(false);
      sessionStorage.removeItem('furnitureRemovalJobId');
      clearInterval(interval);
    }
  }, 2000); // Poll every 2 seconds
};

// Render processing overlay
{isProcessing && (
  <div className="fixed inset-0 bg-black/80 z-50 flex items-center justify-center">
    <div className="text-center">
      <div className="animate-spin rounded-full h-16 w-16 border-t-2 border-purple-500 mb-4" />
      <h2 className="text-xl font-semibold text-white mb-2">
        Preparing your room...
      </h2>
      <p className="text-gray-400">
        Removing existing furniture
      </p>
    </div>
  </div>
)}
```

#### 6. API Utilities (`frontend/src/utils/api.ts`)
```typescript
export async function startFurnitureRemoval(image: string): Promise<{job_id: string, status: string}> {
  const response = await fetch(`${API_BASE_URL}/api/furniture/remove`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ image })
  });
  return response.json();
}

export async function checkFurnitureStatus(job_id: string): Promise<{status: string, image?: string}> {
  const response = await fetch(`${API_BASE_URL}/api/furniture/status/${job_id}`);
  return response.json();
}
```

## Feature 3: Roadmap Updates

Add to `roadmap.md`:

### Future Features (V2.0+)
- **Custom Store URLs**: Allow users to provide their own store URLs for product scraping
- **Selective Furniture Removal**: Let users select specific furniture items to remove instead of removing all furniture automatically

## Files Summary

### New Files (7)
1. `frontend/src/app/store-select/page.tsx` - Store selection page
2. `api/routers/stores.py` - Store list endpoint
3. `api/routers/furniture.py` - Furniture removal endpoints
4. `api/services/furniture_removal_service.py` - Job tracking service
5. `frontend/src/components/StoreSelector.tsx` - Reusable store selection component
6. `V1.5.md` - This implementation plan

### Modified Files (8)
1. `frontend/src/app/page.tsx` - Routing + furniture removal trigger
2. `frontend/src/app/design/page.tsx` - Store editor + processing UI
3. `frontend/src/utils/api.ts` - New API functions
4. `api/routers/chat.py` - Add selected_stores param
5. `api/services/google_ai_service.py` - Furniture removal method
6. `api/services/recommendation_engine.py` - Store filtering logic
7. `api/main.py` - Register new routers
8. `roadmap.md` - Future features

## Key Design Decisions

### Store Selection
- **Empty selection = All stores**: More user-friendly, no error state needed
- **Two-level filtering**: Primary (backend) vs Secondary (frontend) for flexibility
- **Only show stores with products**: Prevents user confusion with empty results

### Furniture Removal
- **Async + Polling**: Non-blocking UX, users can continue while processing
- **3 retries + timeout**: Handles transient API failures gracefully
- **Caching**: Prevents redundant processing, improves performance
- **Blocking design page**: Ensures users see processed image before interacting
- **Silent fallback**: No error messages, seamless UX with original image

### Session Management
- **Keep chat when changing stores**: Better UX, users don't lose context
- **SessionStorage for state**: Simple, works for single-tab usage
- **Clear products on store change**: Forces fresh recommendations with new filter

## Testing Checklist

### Store Selection
- [ ] Store list loads correctly
- [ ] Multi-select works (select/deselect)
- [ ] "Select All" / "Deselect All" buttons work
- [ ] No selection defaults to all stores
- [ ] Selected stores filter products correctly
- [ ] "Change Stores" from design page works
- [ ] Chat history preserved when changing stores

### Furniture Removal
- [ ] Upload triggers async processing
- [ ] Processing overlay shows on design page
- [ ] Polling works (2s intervals)
- [ ] Processed image displays correctly
- [ ] Fallback to original on failure
- [ ] Cache prevents reprocessing
- [ ] Works for both HomePage and design page upload
- [ ] 3 retry attempts with timeout work

### Integration
- [ ] Full flow: Upload → Store select → Design works
- [ ] Skip upload flow works
- [ ] Design page upload flow works
- [ ] Store changes trigger new recommendations
- [ ] Secondary filtering still works in ProductDiscoveryPanel
